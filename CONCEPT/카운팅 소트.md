# 카운팅 소트

Counting sort는 O(n)의 시간복잡도를 갖습니다. 

<br>

### 정렬 과정

다음과 같은 수열 A를 정렬 해야하는 상황에서

​										**A: 5,5,3,4,5,1**

위 수열을 정렬하면 아래와 같은 수열 B를 얻습니다.

 									   **B: 1,3,4,5,5,5**

<br>

#### STEP)

* **각 숫자가 몇 번 나오는지 카운팅**

| 숫자      |  1   |  3   |  4   |  5   |
| :-------- | :--: | :--: | :--: | :--: |
| 등장 횟수 |  1   |  1   |  1   |  3   |

* 등장 횟수를 **누적합**으로 바꿔준다.

| 숫자   | 1     | 3       | 4         | 5           |
| ------ | ----- | ------- | --------- | ----------- |
| 누적합 | 1 (1) | 2 (1+1) | 3 (1+1+1) | 6 (1+1+1+3) |

> 이 누적합을 참고하여, 숫자 1은 1번 인덱스에, 숫자 3은 2번 인덱스에, 숫자 4는 3번 인덱스에, 숫자 5는 4~6번 인덱스에 위치한다는 것을 알 수 있습니다.

* `정렬할 배열 A`를 맨 뒤 인덱스부터 앞으로 순회하면서, `정렬할 배열 B`에 누적합을 참고하여 맞는 인덱스에 넣어줍니다. 

* 숫자 5와 같이 여러번 등장하는 숫자는 제 자리를 찾아가면서 **누적합을 -1** 합니다.

<br>

### 구현 코드

```java
import java.util.Arrays;

public class 카운팅소트 {
	public static void main(String[] args) {
		int[] arr = {3,1,0,4,5,2,3,7};
		//0. 자료들의 최소치부터 최대치까지를 인덱스로 담을 수 있는 넉넉한 크기의 카운트 배열을 준비
		int[] count = new int[8];
		//1. 각 자료들의 빈도수를 카운트배열에 작성
		for(int i = 0; i < arr.length; i++)
			count[arr[i]]++;
		//2. 1번 카운트배열을 누적합으로 변경
		for(int i = 1; i < count.length; i++)
			count[i] += count[i-1];
		//3. 원래 자료배열 크기의 배열을 하나 더 준비 ← 정렬배열
		int[] sortedArr = new int[arr.length];
		//4. 원래 자료배열을 순회하며, 해당 인덱스의 카운트 배열의 값을 1 깎고 그 위치의 정렬배열에 배치
		for(int i = 0; i < arr.length; i++) {
			//내위치
			count[arr[i]] -= 1;
			sortedArr[ count[arr[i]] ] = arr[i];
//			sortedArr[ --count[arr[i]] ] = arr[i];
		}
		System.out.println(Arrays.toString(sortedArr));
	}
}
```